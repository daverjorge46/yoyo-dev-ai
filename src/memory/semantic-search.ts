/**
 * Semantic Search Module
 *
 * Provides vector similarity search for memory blocks using embeddings.
 * Supports:
 * - Pure semantic search (embedding similarity)
 * - Keyword search (text matching)
 * - Hybrid search (combined semantic + keyword)
 */

import type { MemoryStore } from './store.js';
import type { MemoryBlockType, MemoryScope } from './types.js';
import {
  getAllEnhancedBlocks,
  updateBlockEmbeddings,
  incrementAccessCount,
  type EnhancedMemoryBlock,
} from './enhanced-store.js';
import {
  generateEmbedding,
  cosineSimilarity,
  prepareContentForEmbedding,
  type EmbeddingConfig,
} from './embeddings.js';

// =============================================================================
// Types
// =============================================================================

/**
 * Search result with relevance scoring.
 */
export interface SearchResult {
  /** The memory block */
  block: EnhancedMemoryBlock;
  /** Similarity score (0.0 to 1.0) */
  similarity: number;
  /** Combined relevance score */
  relevanceScore: number;
  /** Search method that found this result */
  method: 'semantic' | 'keyword' | 'hybrid';
  /** Matching terms (for keyword/hybrid search) */
  matchingTerms?: string[];
}

/**
 * Search options.
 */
export interface SearchOptions {
  /** Minimum similarity threshold (default: 0.3) */
  threshold?: number;
  /** Maximum results to return (default: 10) */
  limit?: number;
  /** Filter by block type */
  type?: MemoryBlockType;
  /** Filter by scope */
  scope?: MemoryScope;
  /** Search method (default: 'hybrid') */
  method?: 'semantic' | 'keyword' | 'hybrid';
  /** Boost factor for keyword matches (default: 0.2) */
  keywordBoost?: number;
  /** Boost factor for recent access (default: 0.1) */
  recencyBoost?: number;
  /** Track access for retrieved results (default: true) */
  trackAccess?: boolean;
}

/**
 * Search response with metadata.
 */
export interface SearchResponse {
  /** Search results sorted by relevance */
  results: SearchResult[];
  /** Total results found (before limit) */
  total: number;
  /** Query execution time in milliseconds */
  queryTime: number;
  /** Search method used */
  searchMethod: 'semantic' | 'keyword' | 'hybrid';
}

// =============================================================================
// Constants
// =============================================================================

const DEFAULT_OPTIONS: Required<SearchOptions> = {
  threshold: 0.3,
  limit: 10,
  type: undefined as unknown as MemoryBlockType, // Any type
  scope: undefined as unknown as MemoryScope, // Any scope
  method: 'hybrid',
  keywordBoost: 0.2,
  recencyBoost: 0.1,
  trackAccess: true,
};

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Tokenize query for keyword matching.
 */
function tokenizeQuery(query: string): string[] {
  return query
    .toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .split(/\s+/)
    .filter((word) => word.length > 2);
}

/**
 * Check if block content matches query keywords.
 */
function keywordMatch(block: EnhancedMemoryBlock, queryTokens: string[]): {
  matches: boolean;
  matchingTerms: string[];
  score: number;
} {
  const contentText = prepareContentForEmbedding(block.content).toLowerCase();
  const contentTags = block.contextTags.join(' ').toLowerCase();
  const fullText = `${contentText} ${contentTags}`;

  const matchingTerms: string[] = [];

  for (const token of queryTokens) {
    if (fullText.includes(token)) {
      matchingTerms.push(token);
    }
  }

  const score = queryTokens.length > 0 ? matchingTerms.length / queryTokens.length : 0;

  return {
    matches: matchingTerms.length > 0,
    matchingTerms,
    score,
  };
}

/**
 * Calculate combined relevance score.
 */
function calculateRelevance(
  similarity: number,
  block: EnhancedMemoryBlock,
  keywordScore: number,
  options: Required<SearchOptions>
): number {
  // Base relevance from similarity
  let relevance = similarity;

  // Add keyword boost
  relevance += keywordScore * options.keywordBoost;

  // Add recency boost based on access count (logarithmic)
  const accessBoost = Math.log10(block.accessCount + 1) / 10;
  relevance += accessBoost * options.recencyBoost;

  // Factor in block's stored relevance score
  relevance *= block.relevanceScore;

  // Factor in confidence level for auto-generated content
  if (block.autoGenerated) {
    relevance *= block.confidenceLevel;
  }

  return Math.min(relevance, 1.0);
}

// =============================================================================
// Search Functions
// =============================================================================

/**
 * Perform semantic search using embeddings.
 *
 * @param store - MemoryStore instance
 * @param query - Search query
 * @param embeddingConfig - Optional embedding configuration
 * @param options - Search options
 * @returns Search response
 */
export async function semanticSearch(
  store: MemoryStore,
  query: string,
  embeddingConfig?: EmbeddingConfig,
  options: SearchOptions = {}
): Promise<SearchResponse> {
  const startTime = Date.now();
  const opts = { ...DEFAULT_OPTIONS, ...options };

  // Generate query embedding
  const queryEmbedding = await generateEmbedding(query, embeddingConfig);

  // Get all blocks
  let blocks = getAllEnhancedBlocks(store, opts.scope);

  // Filter by type if specified
  if (opts.type) {
    blocks = blocks.filter((b) => b.type === opts.type);
  }

  // Calculate similarities
  const results: SearchResult[] = [];

  for (const block of blocks) {
    // Skip blocks without embeddings
    if (!block.embeddings) continue;

    const similarity = cosineSimilarity(queryEmbedding.embeddings, block.embeddings);

    if (similarity >= opts.threshold) {
      const relevanceScore = calculateRelevance(similarity, block, 0, opts);

      results.push({
        block,
        similarity,
        relevanceScore,
        method: 'semantic',
      });
    }
  }

  // Sort by relevance score
  results.sort((a, b) => b.relevanceScore - a.relevanceScore);

  // Apply limit
  const limitedResults = results.slice(0, opts.limit);

  // Track access if enabled
  if (opts.trackAccess) {
    for (const result of limitedResults) {
      incrementAccessCount(store, result.block.type, result.block.scope);
    }
  }

  return {
    results: limitedResults,
    total: results.length,
    queryTime: Date.now() - startTime,
    searchMethod: 'semantic',
  };
}

/**
 * Perform keyword search using text matching.
 *
 * @param store - MemoryStore instance
 * @param query - Search query
 * @param options - Search options
 * @returns Search response
 */
export function keywordSearch(
  store: MemoryStore,
  query: string,
  options: SearchOptions = {}
): SearchResponse {
  const startTime = Date.now();
  const opts = { ...DEFAULT_OPTIONS, ...options };

  const queryTokens = tokenizeQuery(query);

  // Get all blocks
  let blocks = getAllEnhancedBlocks(store, opts.scope);

  // Filter by type if specified
  if (opts.type) {
    blocks = blocks.filter((b) => b.type === opts.type);
  }

  // Find keyword matches
  const results: SearchResult[] = [];

  for (const block of blocks) {
    const match = keywordMatch(block, queryTokens);

    if (match.matches && match.score >= opts.threshold) {
      const relevanceScore = calculateRelevance(match.score, block, match.score, opts);

      results.push({
        block,
        similarity: match.score,
        relevanceScore,
        method: 'keyword',
        matchingTerms: match.matchingTerms,
      });
    }
  }

  // Sort by relevance score
  results.sort((a, b) => b.relevanceScore - a.relevanceScore);

  // Apply limit
  const limitedResults = results.slice(0, opts.limit);

  // Track access if enabled
  if (opts.trackAccess) {
    for (const result of limitedResults) {
      incrementAccessCount(store, result.block.type, result.block.scope);
    }
  }

  return {
    results: limitedResults,
    total: results.length,
    queryTime: Date.now() - startTime,
    searchMethod: 'keyword',
  };
}

/**
 * Perform hybrid search combining semantic and keyword matching.
 *
 * @param store - MemoryStore instance
 * @param query - Search query
 * @param embeddingConfig - Optional embedding configuration
 * @param options - Search options
 * @returns Search response
 */
export async function hybridSearch(
  store: MemoryStore,
  query: string,
  embeddingConfig?: EmbeddingConfig,
  options: SearchOptions = {}
): Promise<SearchResponse> {
  const startTime = Date.now();
  const opts = { ...DEFAULT_OPTIONS, ...options };

  // Generate query embedding
  const queryEmbedding = await generateEmbedding(query, embeddingConfig);
  const queryTokens = tokenizeQuery(query);

  // Get all blocks
  let blocks = getAllEnhancedBlocks(store, opts.scope);

  // Filter by type if specified
  if (opts.type) {
    blocks = blocks.filter((b) => b.type === opts.type);
  }

  // Calculate combined scores
  const results: SearchResult[] = [];
  const seenIds = new Set<string>();

  for (const block of blocks) {
    // Calculate semantic similarity
    let semanticScore = 0;
    if (block.embeddings) {
      semanticScore = cosineSimilarity(queryEmbedding.embeddings, block.embeddings);
    }

    // Calculate keyword match score
    const keywordResult = keywordMatch(block, queryTokens);
    const keywordScore = keywordResult.score;

    // Combine scores (weighted average)
    const combinedSimilarity = semanticScore * 0.7 + keywordScore * 0.3;

    if (combinedSimilarity >= opts.threshold || keywordResult.matches) {
      const relevanceScore = calculateRelevance(combinedSimilarity, block, keywordScore, opts);

      if (!seenIds.has(block.id)) {
        seenIds.add(block.id);
        results.push({
          block,
          similarity: combinedSimilarity,
          relevanceScore,
          method: 'hybrid',
          matchingTerms: keywordResult.matchingTerms,
        });
      }
    }
  }

  // Sort by relevance score
  results.sort((a, b) => b.relevanceScore - a.relevanceScore);

  // Apply limit
  const limitedResults = results.slice(0, opts.limit);

  // Track access if enabled
  if (opts.trackAccess) {
    for (const result of limitedResults) {
      incrementAccessCount(store, result.block.type, result.block.scope);
    }
  }

  return {
    results: limitedResults,
    total: results.length,
    queryTime: Date.now() - startTime,
    searchMethod: 'hybrid',
  };
}

/**
 * Main search function - automatically selects search method.
 *
 * @param store - MemoryStore instance
 * @param query - Search query
 * @param embeddingConfig - Optional embedding configuration
 * @param options - Search options
 * @returns Search response
 */
export async function search(
  store: MemoryStore,
  query: string,
  embeddingConfig?: EmbeddingConfig,
  options: SearchOptions = {}
): Promise<SearchResponse> {
  const method = options.method ?? 'hybrid';

  switch (method) {
    case 'semantic':
      return semanticSearch(store, query, embeddingConfig, options);
    case 'keyword':
      return keywordSearch(store, query, options);
    case 'hybrid':
    default:
      return hybridSearch(store, query, embeddingConfig, options);
  }
}

// =============================================================================
// Embedding Management
// =============================================================================

/**
 * Generate and store embeddings for a block.
 *
 * @param store - MemoryStore instance
 * @param type - Block type
 * @param scope - Block scope
 * @param embeddingConfig - Embedding configuration
 * @returns true if embeddings were generated and stored
 */
export async function generateBlockEmbeddings(
  store: MemoryStore,
  type: MemoryBlockType,
  scope: MemoryScope,
  embeddingConfig?: EmbeddingConfig
): Promise<boolean> {
  // Get the block
  const blocks = getAllEnhancedBlocks(store, scope);
  const block = blocks.find((b) => b.type === type);

  if (!block) return false;

  // Prepare content for embedding
  const text = prepareContentForEmbedding(block.content);

  // Generate embedding
  const result = await generateEmbedding(text, embeddingConfig);

  // Store embedding
  return updateBlockEmbeddings(store, type, scope, result.embeddings);
}

/**
 * Generate embeddings for all blocks that don't have them.
 *
 * @param store - MemoryStore instance
 * @param embeddingConfig - Embedding configuration
 * @returns Number of blocks updated
 */
export async function generateMissingEmbeddings(
  store: MemoryStore,
  embeddingConfig?: EmbeddingConfig
): Promise<number> {
  const blocks = getAllEnhancedBlocks(store);
  let updated = 0;

  for (const block of blocks) {
    if (!block.embeddings) {
      const text = prepareContentForEmbedding(block.content);
      const result = await generateEmbedding(text, embeddingConfig);
      const success = updateBlockEmbeddings(store, block.type, block.scope, result.embeddings);
      if (success) updated++;
    }
  }

  return updated;
}

/**
 * Find similar blocks to a given block.
 *
 * @param store - MemoryStore instance
 * @param type - Block type to find similar blocks for
 * @param scope - Block scope
 * @param options - Search options
 * @returns Array of similar blocks with similarity scores
 */
export function findSimilarBlocks(
  store: MemoryStore,
  type: MemoryBlockType,
  scope: MemoryScope,
  options: SearchOptions = {}
): SearchResult[] {
  const opts = { ...DEFAULT_OPTIONS, ...options };

  // Get the reference block
  const blocks = getAllEnhancedBlocks(store);
  const referenceBlock = blocks.find((b) => b.type === type && b.scope === scope);

  if (!referenceBlock || !referenceBlock.embeddings) {
    return [];
  }

  // Find similar blocks
  const results: SearchResult[] = [];

  for (const block of blocks) {
    // Skip the reference block itself
    if (block.id === referenceBlock.id) continue;

    // Skip blocks without embeddings
    if (!block.embeddings) continue;

    const similarity = cosineSimilarity(referenceBlock.embeddings, block.embeddings);

    if (similarity >= opts.threshold) {
      results.push({
        block,
        similarity,
        relevanceScore: similarity * block.relevanceScore,
        method: 'semantic',
      });
    }
  }

  // Sort by similarity
  results.sort((a, b) => b.similarity - a.similarity);

  return results.slice(0, opts.limit);
}
