/**
 * Enhanced Memory Store Tests
 *
 * Tests for enhanced memory storage with:
 * - Embeddings support
 * - Relevance scoring
 * - Auto-tagging
 * - Context tags
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { existsSync, mkdirSync, rmSync } from 'node:fs';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import {
  initializeDatabase,
  closeDatabase,
  saveBlock,
  getBlock,
  getAllBlocks,
  type MemoryStore,
} from '../store.js';
import {
  saveEnhancedBlock,
  getEnhancedBlock,
  updateBlockEmbeddings,
  updateBlockRelevance,
  updateBlockTags,
  getBlocksByTags,
  getBlocksByRelevance,
  incrementAccessCount,
  type EnhancedMemoryBlock,
} from '../enhanced-store.js';
import type { MemoryBlockType, MemoryScope, ProjectContent } from '../types.js';

// =============================================================================
// Test Setup
// =============================================================================

const TEST_DIR = join(tmpdir(), 'yoyo-memory-enhanced-test');

function getTestDbPath(): string {
  return join(TEST_DIR, `test-${Date.now()}-${Math.random().toString(36).slice(2)}.db`);
}

describe('Enhanced Memory Store', () => {
  let store: MemoryStore;
  let dbPath: string;

  beforeEach(() => {
    if (!existsSync(TEST_DIR)) {
      mkdirSync(TEST_DIR, { recursive: true });
    }
    dbPath = getTestDbPath();
    store = initializeDatabase(dbPath);
  });

  afterEach(() => {
    if (store) {
      closeDatabase(store);
    }
    if (dbPath && existsSync(dbPath)) {
      rmSync(dbPath, { force: true });
    }
  });

  // ===========================================================================
  // Basic Enhanced Block Operations
  // ===========================================================================

  describe('saveEnhancedBlock', () => {
    it('should save a block with embeddings', () => {
      const embeddings = [0.1, 0.2, 0.3, 0.4, 0.5];
      const content: ProjectContent = {
        name: 'Test Project',
        description: 'A test project',
        tech_stack: { language: 'TypeScript', framework: 'React' },
        architecture: 'monolith',
        patterns: ['TDD'],
        key_directories: { src: 'Source code' },
      };

      const block = saveEnhancedBlock(store, {
        type: 'project',
        scope: 'project',
        content,
        embeddings,
        contextTags: ['typescript', 'react', 'frontend'],
      });

      expect(block).toBeDefined();
      expect(block.embeddings).toEqual(embeddings);
      expect(block.contextTags).toEqual(['typescript', 'react', 'frontend']);
      expect(block.relevanceScore).toBe(1.0); // Default
      expect(block.accessCount).toBe(0);
      expect(block.autoGenerated).toBe(false);
      expect(block.confidenceLevel).toBe(1.0);
    });

    it('should save a block without embeddings', () => {
      const content: ProjectContent = {
        name: 'Test Project',
        description: 'A test project',
        tech_stack: { language: 'TypeScript', framework: 'React' },
        architecture: 'monolith',
        patterns: [],
        key_directories: {},
      };

      const block = saveEnhancedBlock(store, {
        type: 'project',
        scope: 'project',
        content,
      });

      expect(block).toBeDefined();
      expect(block.embeddings).toBeNull();
      expect(block.contextTags).toEqual([]);
    });

    it('should mark auto-generated blocks', () => {
      const content: ProjectContent = {
        name: 'Auto Project',
        description: 'Auto-generated',
        tech_stack: { language: 'Python', framework: 'Django' },
        architecture: 'monolith',
        patterns: [],
        key_directories: {},
      };

      const block = saveEnhancedBlock(store, {
        type: 'project',
        scope: 'project',
        content,
        autoGenerated: true,
        confidenceLevel: 0.8,
      });

      expect(block.autoGenerated).toBe(true);
      expect(block.confidenceLevel).toBe(0.8);
    });
  });

  describe('getEnhancedBlock', () => {
    it('should retrieve enhanced block with all fields', () => {
      const embeddings = [0.1, 0.2, 0.3];
      const content: ProjectContent = {
        name: 'Test',
        description: 'Test',
        tech_stack: { language: 'TypeScript', framework: 'Node' },
        architecture: 'serverless',
        patterns: ['functional'],
        key_directories: {},
      };

      saveEnhancedBlock(store, {
        type: 'project',
        scope: 'project',
        content,
        embeddings,
        contextTags: ['node', 'serverless'],
        relevanceScore: 0.95,
      });

      const retrieved = getEnhancedBlock(store, 'project', 'project');

      expect(retrieved).toBeDefined();
      expect(retrieved?.embeddings).toEqual(embeddings);
      expect(retrieved?.contextTags).toEqual(['node', 'serverless']);
      expect(retrieved?.relevanceScore).toBe(0.95);
    });

    it('should return null for non-existent block', () => {
      const block = getEnhancedBlock(store, 'project', 'project');
      expect(block).toBeNull();
    });
  });

  // ===========================================================================
  // Embeddings Operations
  // ===========================================================================

  describe('updateBlockEmbeddings', () => {
    it('should update embeddings for existing block', () => {
      const content: ProjectContent = {
        name: 'Test',
        description: 'Test',
        tech_stack: { language: 'TypeScript', framework: 'React' },
        architecture: 'monolith',
        patterns: [],
        key_directories: {},
      };

      saveEnhancedBlock(store, {
        type: 'project',
        scope: 'project',
        content,
      });

      const newEmbeddings = [0.5, 0.6, 0.7, 0.8];
      const updated = updateBlockEmbeddings(store, 'project', 'project', newEmbeddings);

      expect(updated).toBe(true);

      const block = getEnhancedBlock(store, 'project', 'project');
      expect(block?.embeddings).toEqual(newEmbeddings);
    });

    it('should return false for non-existent block', () => {
      const result = updateBlockEmbeddings(store, 'project', 'project', [0.1, 0.2]);
      expect(result).toBe(false);
    });
  });

  // ===========================================================================
  // Relevance Scoring
  // ===========================================================================

  describe('updateBlockRelevance', () => {
    it('should update relevance score', () => {
      const content: ProjectContent = {
        name: 'Test',
        description: 'Test',
        tech_stack: { language: 'TypeScript', framework: 'React' },
        architecture: 'monolith',
        patterns: [],
        key_directories: {},
      };

      saveEnhancedBlock(store, {
        type: 'project',
        scope: 'project',
        content,
      });

      updateBlockRelevance(store, 'project', 'project', 0.75);

      const block = getEnhancedBlock(store, 'project', 'project');
      expect(block?.relevanceScore).toBe(0.75);
    });
  });

  describe('getBlocksByRelevance', () => {
    it('should return blocks sorted by relevance', () => {
      const content1: ProjectContent = {
        name: 'Project 1',
        description: 'First project',
        tech_stack: { language: 'TypeScript', framework: 'React' },
        architecture: 'monolith',
        patterns: [],
        key_directories: {},
      };

      const content2: ProjectContent = {
        name: 'Project 2',
        description: 'Second project',
        tech_stack: { language: 'Python', framework: 'Django' },
        architecture: 'microservices',
        patterns: [],
        key_directories: {},
      };

      saveEnhancedBlock(store, {
        type: 'project',
        scope: 'project',
        content: content1,
        relevanceScore: 0.5,
      });

      saveEnhancedBlock(store, {
        type: 'project',
        scope: 'global',
        content: content2,
        relevanceScore: 0.9,
      });

      const blocks = getBlocksByRelevance(store, 0.3);

      expect(blocks.length).toBe(2);
      expect(blocks[0].relevanceScore).toBeGreaterThanOrEqual(blocks[1].relevanceScore);
    });

    it('should filter by minimum relevance', () => {
      const content: ProjectContent = {
        name: 'Test',
        description: 'Test',
        tech_stack: { language: 'TypeScript', framework: 'React' },
        architecture: 'monolith',
        patterns: [],
        key_directories: {},
      };

      saveEnhancedBlock(store, {
        type: 'project',
        scope: 'project',
        content,
        relevanceScore: 0.3,
      });

      const blocks = getBlocksByRelevance(store, 0.5);
      expect(blocks.length).toBe(0);
    });
  });

  // ===========================================================================
  // Auto-Tagging
  // ===========================================================================

  describe('updateBlockTags', () => {
    it('should update context tags', () => {
      const content: ProjectContent = {
        name: 'Test',
        description: 'Test',
        tech_stack: { language: 'TypeScript', framework: 'React' },
        architecture: 'monolith',
        patterns: [],
        key_directories: {},
      };

      saveEnhancedBlock(store, {
        type: 'project',
        scope: 'project',
        content,
        contextTags: ['old-tag'],
      });

      updateBlockTags(store, 'project', 'project', ['new-tag-1', 'new-tag-2']);

      const block = getEnhancedBlock(store, 'project', 'project');
      expect(block?.contextTags).toEqual(['new-tag-1', 'new-tag-2']);
    });
  });

  describe('getBlocksByTags', () => {
    it('should find blocks by tag', () => {
      const content1: ProjectContent = {
        name: 'React Project',
        description: 'A React project',
        tech_stack: { language: 'TypeScript', framework: 'React' },
        architecture: 'spa',
        patterns: [],
        key_directories: {},
      };

      const content2: ProjectContent = {
        name: 'Vue Project',
        description: 'A Vue project',
        tech_stack: { language: 'TypeScript', framework: 'Vue' },
        architecture: 'spa',
        patterns: [],
        key_directories: {},
      };

      saveEnhancedBlock(store, {
        type: 'project',
        scope: 'project',
        content: content1,
        contextTags: ['react', 'typescript', 'frontend'],
      });

      saveEnhancedBlock(store, {
        type: 'project',
        scope: 'global',
        content: content2,
        contextTags: ['vue', 'typescript', 'frontend'],
      });

      const reactBlocks = getBlocksByTags(store, ['react']);
      expect(reactBlocks.length).toBe(1);
      expect((reactBlocks[0].content as ProjectContent).name).toBe('React Project');

      const frontendBlocks = getBlocksByTags(store, ['frontend']);
      expect(frontendBlocks.length).toBe(2);

      const tsReactBlocks = getBlocksByTags(store, ['typescript', 'react']);
      expect(tsReactBlocks.length).toBe(1);
    });

    it('should return empty array for no matching tags', () => {
      const blocks = getBlocksByTags(store, ['nonexistent']);
      expect(blocks).toEqual([]);
    });
  });

  // ===========================================================================
  // Access Tracking
  // ===========================================================================

  describe('incrementAccessCount', () => {
    it('should increment access count', () => {
      const content: ProjectContent = {
        name: 'Test',
        description: 'Test',
        tech_stack: { language: 'TypeScript', framework: 'React' },
        architecture: 'monolith',
        patterns: [],
        key_directories: {},
      };

      saveEnhancedBlock(store, {
        type: 'project',
        scope: 'project',
        content,
      });

      incrementAccessCount(store, 'project', 'project');
      let block = getEnhancedBlock(store, 'project', 'project');
      expect(block?.accessCount).toBe(1);

      incrementAccessCount(store, 'project', 'project');
      block = getEnhancedBlock(store, 'project', 'project');
      expect(block?.accessCount).toBe(2);
    });
  });

  // ===========================================================================
  // Backward Compatibility
  // ===========================================================================

  describe('Backward Compatibility', () => {
    it('should work with legacy saveBlock', () => {
      const content: ProjectContent = {
        name: 'Legacy Project',
        description: 'Saved with legacy method',
        tech_stack: { language: 'JavaScript', framework: 'Express' },
        architecture: 'monolith',
        patterns: [],
        key_directories: {},
      };

      // Save with legacy method
      const legacyBlock = saveBlock(store, {
        type: 'project',
        scope: 'project',
        content,
      });

      expect(legacyBlock).toBeDefined();

      // Retrieve with enhanced method
      const enhancedBlock = getEnhancedBlock(store, 'project', 'project');

      expect(enhancedBlock).toBeDefined();
      expect(enhancedBlock?.embeddings).toBeNull();
      expect(enhancedBlock?.contextTags).toEqual([]);
      expect(enhancedBlock?.relevanceScore).toBe(1.0);
      expect(enhancedBlock?.accessCount).toBe(0);
    });

    it('should allow updating legacy blocks with enhanced fields', () => {
      const content: ProjectContent = {
        name: 'Legacy Project',
        description: 'To be enhanced',
        tech_stack: { language: 'JavaScript', framework: 'Express' },
        architecture: 'monolith',
        patterns: [],
        key_directories: {},
      };

      // Save with legacy method
      saveBlock(store, {
        type: 'project',
        scope: 'project',
        content,
      });

      // Update with enhanced features
      updateBlockEmbeddings(store, 'project', 'project', [0.1, 0.2, 0.3]);
      updateBlockTags(store, 'project', 'project', ['enhanced', 'tagged']);

      const block = getEnhancedBlock(store, 'project', 'project');
      expect(block?.embeddings).toEqual([0.1, 0.2, 0.3]);
      expect(block?.contextTags).toEqual(['enhanced', 'tagged']);
    });
  });
});
