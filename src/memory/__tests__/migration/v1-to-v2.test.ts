/**
 * Migration Tests: V1 to V2 Schema
 *
 * Tests the database migration from schema v1 to v2,
 * ensuring data integrity and backward compatibility.
 */

import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import { join } from 'path';
import { existsSync, rmSync, mkdirSync } from 'fs';
import { tmpdir } from 'os';

import {
  initializeDatabase,
  closeDatabase,
  saveBlock,
  getBlock,
  getAllBlocks,
  type MemoryStore,
} from '../../store.js';

import {
  ensureEnhancedSchema,
  getEnhancedBlock,
  getAllEnhancedBlocks,
  updateBlockEmbeddings,
  updateBlockRelevance,
  updateBlockTags,
  hasEnhancedColumns,
} from '../../enhanced-store.js';

import {
  applyMigration,
  getMigrationStatus,
  isMigrationApplied,
  MIGRATION_VERSION,
} from '../../migrations/v2-enhanced-schema.js';

// =============================================================================
// Test Helpers
// =============================================================================

function createTestDb(): string {
  const testDir = join(tmpdir(), `migration-test-${Date.now()}`);
  mkdirSync(testDir, { recursive: true });
  return join(testDir, 'memory.db');
}

function cleanupTestDb(dbPath: string): void {
  const dir = dbPath.replace(/\/[^/]+$/, '');
  if (existsSync(dir)) {
    rmSync(dir, { recursive: true, force: true });
  }
}

// =============================================================================
// Migration Tests
// =============================================================================

describe('V1 to V2 Migration', () => {
  let dbPath: string;
  let store: MemoryStore;

  beforeEach(() => {
    dbPath = createTestDb();
    store = initializeDatabase(dbPath);
  });

  afterEach(() => {
    if (store) {
      closeDatabase(store);
    }
    cleanupTestDb(dbPath);
  });

  describe('Migration Process', () => {
    test('should apply migration successfully', () => {
      // Create some initial blocks
      const id1 = saveBlock(store, {
        type: 'project',
        scope: 'project',
        content: { name: 'Test Project' },
      });

      const id2 = saveBlock(store, {
        type: 'user',
        scope: 'project',
        content: { preferences: {} },
      });

      // Apply migration
      const result = applyMigration(store);

      expect(result.success).toBe(true);
      expect(result.toVersion).toBe(MIGRATION_VERSION);
    });

    test('should be idempotent (safe to run multiple times)', () => {
      saveBlock(store, {
        type: 'project',
        scope: 'project',
        content: { name: 'Test' },
      });

      // First migration
      const result1 = applyMigration(store);
      expect(result1.success).toBe(true);

      // Second migration (should be no-op)
      const result2 = applyMigration(store);
      expect(result2.success).toBe(true);
      expect(result2.alreadyApplied).toBe(true);
    });

    test('should add enhanced columns after migration', () => {
      applyMigration(store);

      expect(hasEnhancedColumns(store)).toBe(true);
    });
  });

  describe('Data Integrity After Migration', () => {
    test('should preserve all existing blocks', () => {
      const ids = [
        saveBlock(store, { type: 'project', scope: 'project', content: { name: 'Project' } }),
        saveBlock(store, { type: 'user', scope: 'project', content: { name: 'User' } }),
        saveBlock(store, { type: 'persona', scope: 'global', content: { name: 'Persona' } }),
      ];

      applyMigration(store);

      const blocks = getAllBlocks(store);
      expect(blocks.length).toBe(ids.length);

      for (const id of ids) {
        const block = getBlock(store, id);
        expect(block).not.toBeNull();
      }
    });

    test('should preserve block content exactly', () => {
      const originalContent = { name: 'Test', nested: { deep: true, value: 123 } };

      const id = saveBlock(store, {
        type: 'project',
        scope: 'project',
        content: originalContent,
      });

      applyMigration(store);

      const block = getBlock(store, id);
      expect(block!.content).toEqual(originalContent);
    });

    test('should set default values for new columns', () => {
      const id = saveBlock(store, {
        type: 'project',
        scope: 'project',
        content: { name: 'Test' },
      });

      applyMigration(store);

      const block = getEnhancedBlock(store, id);

      expect(block!.relevanceScore).toBe(1.0);
      expect(block!.accessCount).toBe(0);
      expect(block!.contextTags).toEqual([]);
      expect(block!.autoGenerated).toBe(false);
      expect(block!.confidenceLevel).toBe(1.0);
    });
  });

  describe('Migration Status', () => {
    test('should report correct status before migration', () => {
      const status = getMigrationStatus(store);

      expect(status.needsMigration).toBe(true);
      expect(status.targetVersion).toBe(MIGRATION_VERSION);
    });

    test('should report correct status after migration', () => {
      applyMigration(store);

      const status = getMigrationStatus(store);

      expect(status.needsMigration).toBe(false);
      expect(status.hasEnhancedColumns).toBe(true);
    });

    test('isMigrationApplied should return true after migration', () => {
      expect(isMigrationApplied(store)).toBe(false);

      applyMigration(store);

      expect(isMigrationApplied(store)).toBe(true);
    });
  });

  describe('Backward Compatibility', () => {
    test('v1 operations should work on migrated database', () => {
      const id1 = saveBlock(store, {
        type: 'project',
        scope: 'project',
        content: { name: 'Original' },
      });

      applyMigration(store);

      // Standard v1 operations should still work
      const newId = saveBlock(store, {
        type: 'project',
        scope: 'global',
        content: { name: 'New Block' },
      });

      const block = getBlock(store, newId);
      expect(block).not.toBeNull();
      expect(block!.content.name).toBe('New Block');

      const allBlocks = getAllBlocks(store);
      expect(allBlocks.length).toBe(2);
    });

    test('v2 operations should work on migrated database', () => {
      const id = saveBlock(store, {
        type: 'project',
        scope: 'project',
        content: { name: 'Test' },
      });

      applyMigration(store);

      // V2 operations should work
      const enhancedBlocks = getAllEnhancedBlocks(store);
      expect(enhancedBlocks.length).toBe(1);

      const enhancedBlock = getEnhancedBlock(store, id);
      expect(enhancedBlock).not.toBeNull();
      expect(enhancedBlock!.relevanceScore).toBeDefined();
    });

    test('should be able to update enhanced fields after migration', () => {
      const id = saveBlock(store, {
        type: 'project',
        scope: 'project',
        content: { name: 'Test' },
      });

      applyMigration(store);

      // Update enhanced fields
      updateBlockEmbeddings(store, id, [0.1, 0.2, 0.3]);
      updateBlockRelevance(store, id, 0.75);
      updateBlockTags(store, id, ['migrated', 'tested']);

      const block = getEnhancedBlock(store, id);
      expect(block!.embeddings).toEqual([0.1, 0.2, 0.3]);
      expect(block!.relevanceScore).toBe(0.75);
      expect(block!.contextTags).toEqual(['migrated', 'tested']);
    });
  });

  describe('ensureEnhancedSchema Integration', () => {
    test('should migrate database automatically', () => {
      saveBlock(store, {
        type: 'project',
        scope: 'project',
        content: { name: 'Test' },
      });

      // This should trigger migration if needed
      ensureEnhancedSchema(store);

      expect(hasEnhancedColumns(store)).toBe(true);
    });

    test('should not fail on already migrated database', () => {
      // Apply twice - should be safe
      ensureEnhancedSchema(store);
      ensureEnhancedSchema(store);

      expect(hasEnhancedColumns(store)).toBe(true);
    });
  });
});

describe('Fresh V2 Database', () => {
  let dbPath: string;
  let store: MemoryStore;

  beforeEach(() => {
    dbPath = createTestDb();
    store = initializeDatabase(dbPath);
    ensureEnhancedSchema(store);
  });

  afterEach(() => {
    if (store) {
      closeDatabase(store);
    }
    cleanupTestDb(dbPath);
  });

  test('should create v2 database with all features', () => {
    const status = getMigrationStatus(store);
    expect(status.hasEnhancedColumns).toBe(true);
  });

  test('new blocks should have enhanced features', () => {
    const id = saveBlock(store, {
      type: 'project',
      scope: 'project',
      content: { name: 'Fresh Block' },
    });

    const block = getEnhancedBlock(store, id);

    expect(block!.relevanceScore).toBe(1.0);
    expect(block!.accessCount).toBe(0);
    expect(block!.autoGenerated).toBe(false);
  });

  test('should support full v2 operations', () => {
    const id = saveBlock(store, {
      type: 'user',
      scope: 'project',
      content: { preferences: { theme: 'dark' } },
    });

    updateBlockEmbeddings(store, id, [0.5, 0.5, 0.5, 0.5]);
    updateBlockRelevance(store, id, 0.9);
    updateBlockTags(store, id, ['user', 'preferences', 'v2']);

    const block = getEnhancedBlock(store, id);

    expect(block!.embeddings).toHaveLength(4);
    expect(block!.relevanceScore).toBe(0.9);
    expect(block!.contextTags).toContain('v2');
  });
});

describe('Database Persistence', () => {
  let dbPath: string;

  beforeEach(() => {
    dbPath = createTestDb();
  });

  afterEach(() => {
    cleanupTestDb(dbPath);
  });

  test('should persist data across reopens', () => {
    // First session
    let store = initializeDatabase(dbPath);
    ensureEnhancedSchema(store);

    const id = saveBlock(store, {
      type: 'project',
      scope: 'project',
      content: { name: 'Persist Test' },
    });

    updateBlockRelevance(store, id, 0.77);

    closeDatabase(store);

    // Second session
    store = initializeDatabase(dbPath);

    const block = getEnhancedBlock(store, id);
    expect(block).not.toBeNull();
    expect(block!.content.name).toBe('Persist Test');
    expect(block!.relevanceScore).toBe(0.77);

    closeDatabase(store);
  });
});
