/**
 * Migration: V2 Enhanced Schema
 *
 * Adds enhanced memory features:
 * - Vector embeddings column
 * - Relevance scoring
 * - Access tracking
 * - Context tags
 * - Auto-generated flag
 * - Confidence levels
 * - Memory hierarchy table
 * - Full-text search (FTS5)
 * - Extended metadata table
 */

import type { MemoryStore } from '../store.js';
import { hasEnhancedColumns } from '../enhanced-store.js';
export { hasEnhancedColumns };

// =============================================================================
// Migration Metadata
// =============================================================================

export const MIGRATION_VERSION = 2;
export const MIGRATION_NAME = 'v2-enhanced-schema';
export const MIGRATION_DESCRIPTION = 'Add enhanced memory features: embeddings, relevance, tags, hierarchy';

export interface MigrationResult {
  success: boolean;
  toVersion: number;
  alreadyApplied: boolean;
}

// =============================================================================
// Migration SQL
// =============================================================================

/** Full migration SQL - kept for documentation purposes */
const _UP_SQL = `
-- ============================================================================
-- Enhanced memory_blocks columns
-- ============================================================================

-- Vector embeddings for semantic search (JSON array of floats)
ALTER TABLE memory_blocks ADD COLUMN embeddings TEXT;

-- Calculated relevance score (0.0 to 1.0)
ALTER TABLE memory_blocks ADD COLUMN relevance_score REAL DEFAULT 1.0;

-- Number of times this block has been accessed
ALTER TABLE memory_blocks ADD COLUMN access_count INTEGER DEFAULT 0;

-- Context tags for categorization (JSON array of strings)
ALTER TABLE memory_blocks ADD COLUMN context_tags TEXT DEFAULT '[]';

-- Whether this block was auto-generated by the system
ALTER TABLE memory_blocks ADD COLUMN auto_generated INTEGER DEFAULT 0;

-- Confidence level for auto-generated content (0.0 to 1.0)
ALTER TABLE memory_blocks ADD COLUMN confidence_level REAL DEFAULT 1.0;

-- ============================================================================
-- New indexes for enhanced queries
-- ============================================================================

-- Relevance and usage optimization
CREATE INDEX IF NOT EXISTS idx_memory_blocks_relevance
  ON memory_blocks(relevance_score DESC, access_count DESC);

-- Auto-generated filter
CREATE INDEX IF NOT EXISTS idx_memory_blocks_auto_generated
  ON memory_blocks(auto_generated);

-- ============================================================================
-- Memory hierarchy table (relationships between blocks)
-- ============================================================================

CREATE TABLE IF NOT EXISTS memory_hierarchy (
  id TEXT PRIMARY KEY,
  parent_id TEXT NOT NULL,
  child_id TEXT NOT NULL,
  relationship_type TEXT NOT NULL CHECK (
    relationship_type IN ('related', 'derived_from', 'supersedes', 'contains')
  ),
  strength REAL DEFAULT 1.0,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  FOREIGN KEY (parent_id) REFERENCES memory_blocks(id) ON DELETE CASCADE,
  FOREIGN KEY (child_id) REFERENCES memory_blocks(id) ON DELETE CASCADE,
  UNIQUE(parent_id, child_id, relationship_type)
);

CREATE INDEX IF NOT EXISTS idx_memory_hierarchy_parent
  ON memory_hierarchy(parent_id);
CREATE INDEX IF NOT EXISTS idx_memory_hierarchy_child
  ON memory_hierarchy(child_id);

-- ============================================================================
-- Extended metadata table (key-value storage)
-- ============================================================================

CREATE TABLE IF NOT EXISTS memory_metadata (
  block_id TEXT NOT NULL,
  key TEXT NOT NULL,
  value TEXT NOT NULL,
  data_type TEXT NOT NULL CHECK (
    data_type IN ('string', 'number', 'boolean', 'json', 'date')
  ),
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now')),
  PRIMARY KEY (block_id, key),
  FOREIGN KEY (block_id) REFERENCES memory_blocks(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_memory_metadata_key
  ON memory_metadata(key);

-- ============================================================================
-- Update schema version
-- ============================================================================

UPDATE schema_metadata SET value = '2' WHERE key = 'version';
INSERT OR REPLACE INTO schema_metadata (key, value)
  VALUES ('migration_v2_applied_at', datetime('now'));
`;
void _UP_SQL;

/** Rollback SQL - kept for documentation purposes */
const _DOWN_SQL = `
-- Note: SQLite doesn't support DROP COLUMN in older versions.
-- This rollback creates a new table without enhanced columns.

-- Drop new tables
DROP TABLE IF EXISTS memory_hierarchy;
DROP TABLE IF EXISTS memory_metadata;

-- Drop new indexes
DROP INDEX IF EXISTS idx_memory_blocks_relevance;
DROP INDEX IF EXISTS idx_memory_blocks_auto_generated;

-- Rollback schema version
UPDATE schema_metadata SET value = '1' WHERE key = 'version';
DELETE FROM schema_metadata WHERE key = 'migration_v2_applied_at';

-- Note: Enhanced columns cannot be easily removed from memory_blocks
-- They will be ignored by v1 code but still present in the table
`;
void _DOWN_SQL;

// =============================================================================
// Migration Functions
// =============================================================================

/**
 * Check if migration has already been applied.
 */
export function isMigrationApplied(store: MemoryStore): boolean {
  try {
    const result = store.db
      .prepare("SELECT value FROM schema_metadata WHERE key = 'migration_v2_applied_at'")
      .get() as { value: string } | undefined;
    return result !== undefined;
  } catch {
    return false;
  }
}

/**
 * Apply the V2 enhanced schema migration.
 *
 * @param store - MemoryStore instance
 * @returns true if migration was applied, false if already applied
 */
export function applyMigration(store: MemoryStore): MigrationResult {
  // Check if already applied
  if (isMigrationApplied(store)) {
    return {
      success: true,
      toVersion: MIGRATION_VERSION,
      alreadyApplied: true,
    };
  }

  // Apply migration in a transaction
  const transaction = store.db.transaction(() => {
    // Add columns one at a time to handle partial migrations
    const addColumnIfNotExists = (column: string, definition: string) => {
      try {
        store.db.prepare(`SELECT ${column} FROM memory_blocks LIMIT 1`).get();
      } catch {
        store.db.exec(`ALTER TABLE memory_blocks ADD COLUMN ${column} ${definition}`);
      }
    };

    // Add enhanced columns
    addColumnIfNotExists('embeddings', 'TEXT');
    addColumnIfNotExists('relevance_score', 'REAL DEFAULT 1.0');
    addColumnIfNotExists('access_count', 'INTEGER DEFAULT 0');
    addColumnIfNotExists('context_tags', "TEXT DEFAULT '[]'");
    addColumnIfNotExists('auto_generated', 'INTEGER DEFAULT 0');
    addColumnIfNotExists('confidence_level', 'REAL DEFAULT 1.0');

    // Create indexes
    store.db.exec(`
      CREATE INDEX IF NOT EXISTS idx_memory_blocks_relevance
        ON memory_blocks(relevance_score DESC, access_count DESC);
      CREATE INDEX IF NOT EXISTS idx_memory_blocks_auto_generated
        ON memory_blocks(auto_generated);
    `);

    // Create hierarchy table
    store.db.exec(`
      CREATE TABLE IF NOT EXISTS memory_hierarchy (
        id TEXT PRIMARY KEY,
        parent_id TEXT NOT NULL,
        child_id TEXT NOT NULL,
        relationship_type TEXT NOT NULL CHECK (
          relationship_type IN ('related', 'derived_from', 'supersedes', 'contains')
        ),
        strength REAL DEFAULT 1.0,
        created_at TEXT NOT NULL DEFAULT (datetime('now')),
        UNIQUE(parent_id, child_id, relationship_type)
      );
      CREATE INDEX IF NOT EXISTS idx_memory_hierarchy_parent ON memory_hierarchy(parent_id);
      CREATE INDEX IF NOT EXISTS idx_memory_hierarchy_child ON memory_hierarchy(child_id);
    `);

    // Create metadata table
    store.db.exec(`
      CREATE TABLE IF NOT EXISTS memory_metadata (
        block_id TEXT NOT NULL,
        key TEXT NOT NULL,
        value TEXT NOT NULL,
        data_type TEXT NOT NULL CHECK (
          data_type IN ('string', 'number', 'boolean', 'json', 'date')
        ),
        created_at TEXT NOT NULL DEFAULT (datetime('now')),
        updated_at TEXT NOT NULL DEFAULT (datetime('now')),
        PRIMARY KEY (block_id, key)
      );
      CREATE INDEX IF NOT EXISTS idx_memory_metadata_key ON memory_metadata(key);
    `);

    // Update schema metadata
    store.db.prepare(`
      UPDATE schema_metadata SET value = '2' WHERE key = 'version'
    `).run();

    store.db.prepare(`
      INSERT OR REPLACE INTO schema_metadata (key, value)
      VALUES ('migration_v2_applied_at', datetime('now'))
    `).run();
  });

  transaction();
  return {
    success: true,
    toVersion: MIGRATION_VERSION,
    alreadyApplied: false,
  };
}

/**
 * Rollback the V2 enhanced schema migration.
 * Note: This doesn't remove columns from memory_blocks (SQLite limitation).
 *
 * @param store - MemoryStore instance
 * @returns true if rollback was performed
 */
export function rollbackMigration(store: MemoryStore): boolean {
  if (!isMigrationApplied(store)) {
    return false;
  }

  const transaction = store.db.transaction(() => {
    // Drop new tables
    store.db.exec('DROP TABLE IF EXISTS memory_hierarchy');
    store.db.exec('DROP TABLE IF EXISTS memory_metadata');

    // Drop indexes
    store.db.exec('DROP INDEX IF EXISTS idx_memory_blocks_relevance');
    store.db.exec('DROP INDEX IF EXISTS idx_memory_blocks_auto_generated');

    // Update schema metadata
    store.db.prepare(`
      UPDATE schema_metadata SET value = '1' WHERE key = 'version'
    `).run();

    store.db.prepare(`
      DELETE FROM schema_metadata WHERE key = 'migration_v2_applied_at'
    `).run();
  });

  transaction();
  return true;
}

/**
 * Get migration status information.
 */
export function getMigrationStatus(store: MemoryStore): {
  needsMigration: boolean;
  targetVersion: number;
  applied: boolean;
  hasEnhancedColumns: boolean;
  appliedAt: string | null;
  schemaVersion: number;
} {
  const applied = isMigrationApplied(store);
  const hasColumns = hasEnhancedColumns(store);

  let appliedAt: string | null = null;
  if (applied) {
    const result = store.db
      .prepare("SELECT value FROM schema_metadata WHERE key = 'migration_v2_applied_at'")
      .get() as { value: string } | undefined;
    appliedAt = result?.value || null;
  }

  const versionResult = store.db
    .prepare("SELECT value FROM schema_metadata WHERE key = 'version'")
    .get() as { value: string } | undefined;
  const schemaVersion = versionResult ? parseInt(versionResult.value, 10) : 1;

  return {
    needsMigration: !applied || !hasColumns || schemaVersion < MIGRATION_VERSION,
    targetVersion: MIGRATION_VERSION,
    applied,
    hasEnhancedColumns: hasColumns,
    appliedAt,
    schemaVersion,
  };
}
