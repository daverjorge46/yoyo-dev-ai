/**
 * Enhanced Memory Store
 *
 * Extends the base memory store with:
 * - Vector embeddings for semantic search
 * - Relevance scoring
 * - Auto-tagging and context tags
 * - Access tracking
 * - Confidence levels for auto-generated content
 */

import { v4 as uuidv4 } from 'uuid';
import type {
  MemoryBlockType,
  MemoryScope,
  MemoryBlockContent,
  MemoryBlockRow,
} from './types.js';
import type { MemoryStore } from './store.js';

// =============================================================================
// Types
// =============================================================================

/**
 * Enhanced memory block with additional metadata.
 */
export interface EnhancedMemoryBlock {
  /** Unique identifier (UUID) */
  id: string;
  /** Type of memory block */
  type: MemoryBlockType;
  /** Storage scope (global or project) */
  scope: MemoryScope;
  /** Block content (type depends on block type) */
  content: MemoryBlockContent;
  /** Version number for optimistic locking */
  version: number;
  /** When the block was created */
  createdAt: Date;
  /** When the block was last updated */
  updatedAt: Date;

  // Enhanced fields
  /** Vector embeddings for semantic search (null if not generated) */
  embeddings: number[] | null;
  /** Calculated relevance score (0.0 to 1.0) */
  relevanceScore: number;
  /** Number of times this block has been accessed */
  accessCount: number;
  /** Context tags for categorization */
  contextTags: string[];
  /** Whether this block was auto-generated */
  autoGenerated: boolean;
  /** Confidence level for auto-generated content (0.0 to 1.0) */
  confidenceLevel: number;
}

/**
 * Input for saving an enhanced memory block.
 */
export interface SaveEnhancedBlockInput {
  type: MemoryBlockType;
  scope: MemoryScope;
  content: MemoryBlockContent;
  embeddings?: number[];
  relevanceScore?: number;
  contextTags?: string[];
  autoGenerated?: boolean;
  confidenceLevel?: number;
}

/**
 * Extended row type for enhanced memory blocks.
 */
interface EnhancedMemoryBlockRow extends MemoryBlockRow {
  embeddings: string | null;
  relevance_score: number;
  access_count: number;
  context_tags: string | null;
  auto_generated: number;
  confidence_level: number;
}

// =============================================================================
// Schema Migration
// =============================================================================

/**
 * SQL to add enhanced columns to memory_blocks table.
 * Reserved for future use in batch migrations.
 */
const _ENHANCE_SCHEMA_SQL = `
  -- Add enhanced columns if they don't exist
  -- SQLite doesn't have IF NOT EXISTS for ALTER TABLE, so we use a workaround

  -- Check and add embeddings column
  CREATE TABLE IF NOT EXISTS _enhanced_migration_check (migrated INTEGER);

  -- This will be run by the migration system
`;
void _ENHANCE_SCHEMA_SQL;

/**
 * Ensure enhanced columns exist in the database.
 * Called automatically when using enhanced functions.
 */
export function ensureEnhancedSchema(store: MemoryStore): void {
  const db = store.db;

  // Check if enhanced columns exist by trying to select them
  try {
    db.prepare('SELECT embeddings FROM memory_blocks LIMIT 1').get();
  } catch {
    // Column doesn't exist, add it
    db.exec(`
      ALTER TABLE memory_blocks ADD COLUMN embeddings TEXT;
      ALTER TABLE memory_blocks ADD COLUMN relevance_score REAL DEFAULT 1.0;
      ALTER TABLE memory_blocks ADD COLUMN access_count INTEGER DEFAULT 0;
      ALTER TABLE memory_blocks ADD COLUMN context_tags TEXT;
      ALTER TABLE memory_blocks ADD COLUMN auto_generated INTEGER DEFAULT 0;
      ALTER TABLE memory_blocks ADD COLUMN confidence_level REAL DEFAULT 1.0;
    `);

    // Create indexes for enhanced queries
    db.exec(`
      CREATE INDEX IF NOT EXISTS idx_memory_blocks_relevance
        ON memory_blocks(relevance_score DESC, access_count DESC);
      CREATE INDEX IF NOT EXISTS idx_memory_blocks_auto_generated
        ON memory_blocks(auto_generated);
    `);
  }
}

// =============================================================================
// Row Conversion
// =============================================================================

/**
 * Convert a database row to an EnhancedMemoryBlock.
 */
function rowToEnhancedBlock(row: EnhancedMemoryBlockRow): EnhancedMemoryBlock {
  return {
    id: row.id,
    type: row.type as MemoryBlockType,
    scope: row.scope as MemoryScope,
    content: JSON.parse(row.content) as MemoryBlockContent,
    version: row.version,
    createdAt: new Date(row.created_at),
    updatedAt: new Date(row.updated_at),
    embeddings: row.embeddings ? JSON.parse(row.embeddings) : null,
    relevanceScore: row.relevance_score ?? 1.0,
    accessCount: row.access_count ?? 0,
    contextTags: row.context_tags ? JSON.parse(row.context_tags) : [],
    autoGenerated: Boolean(row.auto_generated),
    confidenceLevel: row.confidence_level ?? 1.0,
  };
}

// =============================================================================
// Enhanced Block Operations
// =============================================================================

/**
 * Save an enhanced memory block.
 * Creates a new block or updates existing one (matched by type + scope).
 *
 * @param store - MemoryStore instance
 * @param input - Enhanced block data to save
 * @returns The saved EnhancedMemoryBlock
 */
export function saveEnhancedBlock(
  store: MemoryStore,
  input: SaveEnhancedBlockInput
): EnhancedMemoryBlock {
  ensureEnhancedSchema(store);

  const id = uuidv4();
  const now = new Date().toISOString();

  const stmt = store.db.prepare(`
    INSERT INTO memory_blocks (
      id, type, scope, content, version, created_at, updated_at,
      embeddings, relevance_score, access_count, context_tags,
      auto_generated, confidence_level
    )
    VALUES (
      @id, @type, @scope, @content, 1, @now, @now,
      @embeddings, @relevanceScore, 0, @contextTags,
      @autoGenerated, @confidenceLevel
    )
    ON CONFLICT(type, scope) DO UPDATE SET
      content = @content,
      version = version + 1,
      updated_at = @now,
      embeddings = COALESCE(@embeddings, embeddings),
      relevance_score = @relevanceScore,
      context_tags = @contextTags,
      auto_generated = @autoGenerated,
      confidence_level = @confidenceLevel
  `);

  stmt.run({
    id,
    type: input.type,
    scope: input.scope,
    content: JSON.stringify(input.content),
    now,
    embeddings: input.embeddings ? JSON.stringify(input.embeddings) : null,
    relevanceScore: input.relevanceScore ?? 1.0,
    contextTags: input.contextTags ? JSON.stringify(input.contextTags) : '[]',
    autoGenerated: input.autoGenerated ? 1 : 0,
    confidenceLevel: input.confidenceLevel ?? 1.0,
  });

  // Return the saved block
  const block = getEnhancedBlock(store, input.type, input.scope);
  if (!block) {
    throw new Error(`Failed to save enhanced block: ${input.type}/${input.scope}`);
  }
  return block;
}

/**
 * Get an enhanced memory block by type and scope.
 *
 * @param store - MemoryStore instance
 * @param type - Block type
 * @param scope - Block scope
 * @returns EnhancedMemoryBlock or null if not found
 */
export function getEnhancedBlock(
  store: MemoryStore,
  id: string
): EnhancedMemoryBlock | null;
export function getEnhancedBlock(
  store: MemoryStore,
  type: MemoryBlockType,
  scope: MemoryScope
): EnhancedMemoryBlock | null;
export function getEnhancedBlock(
  store: MemoryStore,
  typeOrId: MemoryBlockType | string,
  scope?: MemoryScope
): EnhancedMemoryBlock | null {
  ensureEnhancedSchema(store);

  const statement =
    scope === undefined
      ? store.db.prepare('SELECT * FROM memory_blocks WHERE id = ?')
      : store.db.prepare('SELECT * FROM memory_blocks WHERE type = ? AND scope = ?');

  const row = (scope === undefined
    ? statement.get(typeOrId)
    : statement.get(typeOrId, scope)) as EnhancedMemoryBlockRow | undefined;

  if (!row) return null;
  return rowToEnhancedBlock(row);
}

/**
 * Get all enhanced memory blocks for a scope.
 *
 * @param store - MemoryStore instance
 * @param scope - Block scope to filter by (optional, returns all if not specified)
 * @returns Array of EnhancedMemoryBlocks
 */
export function getAllEnhancedBlocks(
  store: MemoryStore,
  scope?: MemoryScope
): EnhancedMemoryBlock[] {
  ensureEnhancedSchema(store);

  let rows: EnhancedMemoryBlockRow[];
  if (scope) {
    rows = store.db
      .prepare('SELECT * FROM memory_blocks WHERE scope = ? ORDER BY type')
      .all(scope) as EnhancedMemoryBlockRow[];
  } else {
    rows = store.db
      .prepare('SELECT * FROM memory_blocks ORDER BY type')
      .all() as EnhancedMemoryBlockRow[];
  }

  return rows.map(rowToEnhancedBlock);
}

// =============================================================================
// Embeddings Operations
// =============================================================================

/**
 * Update embeddings for an existing block.
 *
 * @param store - MemoryStore instance
 * @param type - Block type
 * @param scope - Block scope
 * @param embeddings - New embeddings vector
 * @returns true if updated, false if block not found
 */
export function updateBlockEmbeddings(
  store: MemoryStore,
  id: string,
  embeddings: number[]
): boolean;
export function updateBlockEmbeddings(
  store: MemoryStore,
  type: MemoryBlockType,
  scope: MemoryScope,
  embeddings: number[]
): boolean;
export function updateBlockEmbeddings(
  store: MemoryStore,
  idOrType: MemoryBlockType | string,
  scopeOrEmbeddings: MemoryScope | number[],
  maybeEmbeddings?: number[]
): boolean {
  ensureEnhancedSchema(store);

  const usingId = Array.isArray(scopeOrEmbeddings);
  const embeddings = usingId ? scopeOrEmbeddings : maybeEmbeddings;

  if (!embeddings) {
    return false;
  }

  const statement = store.db.prepare(`
    UPDATE memory_blocks
    SET embeddings = @embeddings, updated_at = datetime('now')
    WHERE ${usingId ? 'id = @id' : 'type = @type AND scope = @scope'}
  `);

  const params = usingId
    ? { embeddings: JSON.stringify(embeddings), id: idOrType }
    : {
        embeddings: JSON.stringify(embeddings),
        type: idOrType as MemoryBlockType,
        scope: scopeOrEmbeddings as MemoryScope,
      };

  const result = statement.run(params);

  return result.changes > 0;
}

// =============================================================================
// Relevance Operations
// =============================================================================

/**
 * Update relevance score for a block.
 *
 * @param store - MemoryStore instance
 * @param type - Block type
 * @param scope - Block scope
 * @param score - New relevance score (0.0 to 1.0)
 * @returns true if updated, false if block not found
 */
export function updateBlockRelevance(
  store: MemoryStore,
  id: string,
  score: number
): boolean;
export function updateBlockRelevance(
  store: MemoryStore,
  type: MemoryBlockType,
  scope: MemoryScope,
  score: number
): boolean;
export function updateBlockRelevance(
  store: MemoryStore,
  idOrType: MemoryBlockType | string,
  scopeOrScore: MemoryScope | number,
  maybeScore?: number
): boolean {
  ensureEnhancedSchema(store);

  const usingId = typeof scopeOrScore === 'number';
  const score = usingId ? scopeOrScore : maybeScore;

  if (score === undefined) {
    return false;
  }

  const clampedScore = Math.max(0, Math.min(1, score));

  const statement = store.db.prepare(`
    UPDATE memory_blocks
    SET relevance_score = @score, updated_at = datetime('now')
    WHERE ${usingId ? 'id = @id' : 'type = @type AND scope = @scope'}
  `);

  const params = usingId
    ? { score: clampedScore, id: idOrType }
    : {
        score: clampedScore,
        type: idOrType as MemoryBlockType,
        scope: scopeOrScore as MemoryScope,
      };

  const result = statement.run(params);

  return result.changes > 0;
}

/**
 * Get blocks sorted by relevance score.
 *
 * @param store - MemoryStore instance
 * @param minRelevance - Minimum relevance threshold (default: 0)
 * @param limit - Maximum number of blocks to return (default: 100)
 * @returns Array of EnhancedMemoryBlocks sorted by relevance (highest first)
 */
export function getBlocksByRelevance(
  store: MemoryStore,
  minRelevance = 0,
  limit = 100
): EnhancedMemoryBlock[] {
  ensureEnhancedSchema(store);

  const rows = store.db
    .prepare(`
      SELECT * FROM memory_blocks
      WHERE relevance_score >= ?
      ORDER BY relevance_score DESC, access_count DESC
      LIMIT ?
    `)
    .all(minRelevance, limit) as EnhancedMemoryBlockRow[];

  return rows.map(rowToEnhancedBlock);
}

// =============================================================================
// Tagging Operations
// =============================================================================

/**
 * Update context tags for a block.
 *
 * @param store - MemoryStore instance
 * @param type - Block type
 * @param scope - Block scope
 * @param tags - New tags array
 * @returns true if updated, false if block not found
 */
export function updateBlockTags(store: MemoryStore, id: string, tags: string[]): boolean;
export function updateBlockTags(
  store: MemoryStore,
  type: MemoryBlockType,
  scope: MemoryScope,
  tags: string[]
): boolean;
export function updateBlockTags(
  store: MemoryStore,
  idOrType: MemoryBlockType | string,
  scopeOrTags: MemoryScope | string[],
  maybeTags?: string[]
): boolean {
  ensureEnhancedSchema(store);

  const usingId = Array.isArray(scopeOrTags);
  const tags = usingId ? scopeOrTags : maybeTags;

  if (!tags) {
    return false;
  }

  const statement = store.db.prepare(`
    UPDATE memory_blocks
    SET context_tags = @tags, updated_at = datetime('now')
    WHERE ${usingId ? 'id = @id' : 'type = @type AND scope = @scope'}
  `);

  const params = usingId
    ? { tags: JSON.stringify(tags), id: idOrType }
    : {
        tags: JSON.stringify(tags),
        type: idOrType as MemoryBlockType,
        scope: scopeOrTags as MemoryScope,
      };

  const result = statement.run(params);

  return result.changes > 0;
}

/**
 * Get blocks that match any of the specified tags.
 *
 * @param store - MemoryStore instance
 * @param tags - Tags to search for
 * @returns Array of EnhancedMemoryBlocks that have all specified tags
 */
export function getBlocksByTags(
  store: MemoryStore,
  tags: string[]
): EnhancedMemoryBlock[] {
  ensureEnhancedSchema(store);

  if (tags.length === 0) return [];

  // Get all blocks and filter in memory (SQLite JSON handling is limited)
  const allBlocks = getAllEnhancedBlocks(store);

  return allBlocks.filter((block) => {
    const blockTags = block.contextTags;
    // Block must have all specified tags
    return tags.every((tag) => blockTags.includes(tag));
  });
}

// =============================================================================
// Access Tracking
// =============================================================================

/**
 * Increment access count for a block.
 *
 * @param store - MemoryStore instance
 * @param type - Block type
 * @param scope - Block scope
 * @returns true if updated, false if block not found
 */
export function incrementAccessCount(
  store: MemoryStore,
  type: MemoryBlockType,
  scope: MemoryScope
): boolean {
  ensureEnhancedSchema(store);

  const result = store.db
    .prepare(`
      UPDATE memory_blocks
      SET access_count = access_count + 1
      WHERE type = ? AND scope = ?
    `)
    .run(type, scope);

  return result.changes > 0;
}

// =============================================================================
// Exports
// =============================================================================

export type { EnhancedMemoryBlockRow };
